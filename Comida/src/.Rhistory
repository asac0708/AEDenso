0.5, 0.2, 1), nrow = 3)
n = 100
grupo1 <- mvrnorm(n = n, mu = mu, Sigma = sigma) %>% data.frame()
grupo2 <- mvrnorm(n = n, mu = mu2, Sigma = sigma2) %>% data.frame()
grupo1[, 'grupo'] <- 'G1'
grupo2[, 'grupo'] <- 'G2'
datos_kmeans %>% ggplot(aes(X1, X2, color = grupo)) +
geom_point()
datos_kmeans <- bind_rows(grupo1, grupo2)
agrupacion <- kmeans(datos_kmeans[, -4], 2)
grupos_predichos <- factor(agrupacion$cluster)
levels(grupos_predichos) <- c('G2', 'G1')
# 3. Calcular cuántos de los puntos fueron mal clasificados y calcular el accuracy
(datos_kmeans$grupo == grupos_predichos) %>% mean()
mu <- c(0, 5, 4)
sigma <- matrix(c(1, 0.2, 0.4,
0.2, 1, 0.3,
0.4, 0.3, 1), nrow = 3)
mu2 <- c(2, 1, 3)
sigma2 <- matrix(c(2, 0.3, 0.5,
0.3, 1.5, 0.2,
0.5, 0.2, 1), nrow = 3)
n = 100
accuracy <- c()
for(i in 1:500){
grupo1 <- mvrnorm(n = n, mu = mu, Sigma = sigma) %>% data.frame()
grupo2 <- mvrnorm(n = n, mu = mu2, Sigma = sigma2) %>% data.frame()
grupo1[, 'grupo'] <- 'G1'
grupo2[, 'grupo'] <- 'G2'
datos_kmeans <- bind_rows(grupo1, grupo2)
agrupacion <- kmeans(datos_kmeans[, -4], 2)
grupos_predichos <- factor(agrupacion$cluster)
levels(grupos_predichos) <- c('G2', 'G1')
accuracy <- append(accuracy,(datos_kmeans$grupo == grupos_predichos) %>% mean())
}
# 2. Hacer variaciones de los centroides para que cada vez estén mas cerca y almacenar el accuracy promedio para cada caso
mu <- c(0, 5, 4)
sigma <- matrix(c(1, 0.2, 0.4,
0.2, 1, 0.3,
0.4, 0.3, 1), nrow = 3)
mu2 <- c(2, 1, 3)
sigma2 <- matrix(c(2, 0.3, 0.5,
0.3, 1.5, 0.2,
0.5, 0.2, 1), nrow = 3)
n <- 100
repeticiones <- 500
accuracy <- numeric(repeticiones)
distancias<- numeric()
# Calcular la distancia de los centroides
centroid_distance <- function(mu1, mu2) {
sqrt((mu1 - mu2)^2)
}
inicial <- centroid_distance(mu, mu2)
distancias <- c(distancias, inicial)
dpp <- medias1-medias2
dpp <- mu-mu2
dpp
dpp_usable <- dpp / repeticiones
dpp_usable
for (i in 1:repeticiones) {
# Colocar los centroides más cerca
nmu1 <- nmu1 + dpp_usable #Acerco la media 1 a la media 2 cada repetición
grupo1 <- mvrnorm(n = n, mu = mu, Sigma = sigma) %>% data.frame()
grupo2 <- mvrnorm(n = n, mu = mu2, Sigma = sigma2) %>% data.frame()
grupo1[, 'grupo'] <- 'G1'
grupo2[, 'grupo'] <- 'G2'
datos_kmeans <- bind_rows(grupo1, grupo2)
agrupacion <- kmeans(datos_kmeans[, -4], 2)
grupos_predichos <- factor(agrupacion$cluster)
levels(grupos_predichos) <- c('G2', 'G1')
accuracy[i] <- mean(datos_kmeans$grupo == grupos_predichos)
distancias[i] <- centroid_distance(agrupacion$centers[1, ], agrupacion$centers[2, ])
}
nmu1 <- mu
for (i in 1:repeticiones) {
# Colocar los centroides más cerca
nmu1 <- nmu1 + dpp_usable #Acerco la media 1 a la media 2 cada repetición
grupo1 <- mvrnorm(n = n, mu = mu, Sigma = sigma) %>% data.frame()
grupo2 <- mvrnorm(n = n, mu = mu2, Sigma = sigma2) %>% data.frame()
grupo1[, 'grupo'] <- 'G1'
grupo2[, 'grupo'] <- 'G2'
datos_kmeans <- bind_rows(grupo1, grupo2)
agrupacion <- kmeans(datos_kmeans[, -4], 2)
grupos_predichos <- factor(agrupacion$cluster)
levels(grupos_predichos) <- c('G2', 'G1')
accuracy[i] <- mean(datos_kmeans$grupo == grupos_predichos)
distancias[i] <- centroid_distance(agrupacion$centers[1, ], agrupacion$centers[2, ])
}
# 3. Hacer un gráfico de accuracy vs distancia ecuclideana entre centroides
resultado <- bind_cols(accuracy, distancias)
for (i in 1:repeticiones) {
# Colocar los centroides más cerca
nmu1 <- nmu1 + dpp_usable #Acerco la media 1 a la media 2 cada repetición
grupo1 <- mvrnorm(n = n, mu = nmu1, Sigma = sigma) %>% data.frame()
grupo2 <- mvrnorm(n = n, mu = mu2, Sigma = sigma2) %>% data.frame()
grupo1[, 'grupo'] <- 'G1'
grupo2[, 'grupo'] <- 'G2'
datos_kmeans <- bind_rows(grupo1, grupo2)
agrupacion <- kmeans(datos_kmeans[, -4], 2)
grupos_predichos <- factor(agrupacion$cluster)
levels(grupos_predichos) <- c('G2', 'G1')
accuracy[i] <- mean(datos_kmeans$grupo == grupos_predichos)
distancias[i] <- centroid_distance(agrupacion$centers[1, ], agrupacion$centers[2, ])
}
warnings()
for (i in 1:repeticiones) {
# Colocar los centroides más cerca
nmu1 <- nmu1 + dpp_usable #Acerco la media 1 a la media 2 cada repetición
grupo1 <- mvrnorm(n = n, mu = nmu1, Sigma = sigma) %>% data.frame()
grupo2 <- mvrnorm(n = n, mu = mu2, Sigma = sigma2) %>% data.frame()
grupo1[, 'grupo'] <- 'G1'
grupo2[, 'grupo'] <- 'G2'
datos_kmeans <- bind_rows(grupo1, grupo2)
agrupacion <- kmeans(datos_kmeans[, -4], 2)
grupos_predichos <- factor(agrupacion$cluster)
levels(grupos_predichos) <- c('G2', 'G1')
accuracy[i] <- mean(datos_kmeans$grupo == grupos_predichos)
distancias[i] <- centroid_distance(agrupacion$centers[1, ], agrupacion$centers[2, ])
}
# 3. Hacer un gráfico de accuracy vs distancia ecuclideana entre centroides
resultado <- bind_cols(accuracy, distancias)
ggplot(resultado, aes(x = ...2 , y = ...1 )) +
geom_line(color = "blue", size = 0.2) +
labs(title = "Gráfico X1 vs X2",
x = "X1", y = "X2") +
theme_minimal()
# Colocar los centroides más cerca
nmu1 <- nmu1 - dpp_usable #Acerco la media 1 a la media 2 cada repetición
grupo1 <- mvrnorm(n = n, mu = nmu1, Sigma = sigma) %>% data.frame()
grupo2 <- mvrnorm(n = n, mu = mu2, Sigma = sigma2) %>% data.frame()
grupo1[, 'grupo'] <- 'G1'
grupo2[, 'grupo'] <- 'G2'
datos_kmeans <- bind_rows(grupo1, grupo2)
agrupacion <- kmeans(datos_kmeans[, -4], 2)
grupos_predichos <- factor(agrupacion$cluster)
levels(grupos_predichos) <- c('G2', 'G1')
accuracy[i] <- mean(datos_kmeans$grupo == grupos_predichos)
distancias[i] <- centroid_distance(agrupacion$centers[1, ], agrupacion$centers[2, ])
nmu1 <- mu
for (i in 1:repeticiones) {
# Colocar los centroides más cerca
nmu1 <- nmu1 - dpp_usable #Acerco la media 1 a la media 2 cada repetición
grupo1 <- mvrnorm(n = n, mu = nmu1, Sigma = sigma) %>% data.frame()
grupo2 <- mvrnorm(n = n, mu = mu2, Sigma = sigma2) %>% data.frame()
grupo1[, 'grupo'] <- 'G1'
grupo2[, 'grupo'] <- 'G2'
datos_kmeans <- bind_rows(grupo1, grupo2)
agrupacion <- kmeans(datos_kmeans[, -4], 2)
grupos_predichos <- factor(agrupacion$cluster)
levels(grupos_predichos) <- c('G2', 'G1')
accuracy[i] <- mean(datos_kmeans$grupo == grupos_predichos)
distancias[i] <- centroid_distance(agrupacion$centers[1, ], agrupacion$centers[2, ])
}
# 3. Hacer un gráfico de accuracy vs distancia ecuclideana entre centroides
resultado <- bind_cols(accuracy, distancias)
ggplot(resultado, aes(x = ...2 , y = ...1 )) +
geom_line(color = "blue", size = 0.2) +
labs(title = "Gráfico X1 vs X2",
x = "X1", y = "X2") +
theme_minimal()
ggplot(resultado, aes(x = ...2 , y = ...1 )) +
geom_point(color = "blue", size = 0.2) +
labs(title = "Gráfico X1 vs X2",
x = "X1", y = "X2") +
theme_minimal()
ggplot(resultado, aes(x = ...2 , y = ...1 )) +
geom_point(color = "blue", size = 1) +
labs(title = "Gráfico X1 vs X2",
x = "X1", y = "X2") +
theme_minimal()
load("~/Dev/AEDenso/ProyectoAEDenso-main/Comida/src/.RData")
View(agrupacion)
View(datos_comida)
View(datos_kmeans)
View(grupo1)
View(grupo2)
#install.packages("summarytools")
library(summarytools)
library(ggplot2)
#install.packages("summarytools")
library(summarytools)
library(ggplot2)
getwd()
setwd("C:/Users/sofia/Documents/Hackaton Datos/Comida/src/")
setwd("C:/Users/jonec/Documents/Dev/AEDenso/Comida/src")
datos_comida <- read.csv("../input/epi_r.csv")
colnames(datos_comida)
unique(datos_comida)
# Filtrar las filas donde 'calories' es mayor que 500
datos_filtrados <- datos_comida[datos_comida$rating == 5.0, ]
# Filtrar las filas donde 'calories' es mayor que 500
datos_filtrados <- datos_comida[datos_comida$rating == 5.0, ]
# Filtrar las filas donde 'calories' es mayor que 500
datos_filtrados <- datos_comida[datos_comida$rating == 5.0, ]
# Crear una lista para almacenar las columnas con medias mayores a 0.75
columnas_altas_media <- c()
# Obtener el número de columnas en datos_filtrados
num_columnas <- ncol(datos_filtrados)
# Recorrer las columnas de la séptima en adelante
for (i in 7:num_columnas) {
# Nombre de la columna actual
nombre_columna <- colnames(datos_filtrados)[i]
# Calcular la media de la columna actual
media_columna <- mean(datos_filtrados[[nombre_columna]])
# Verificar si la media es mayor a 0.75
if (media_columna > 0.75) {
# Agregar el nombre de la columna a la lista
columnas_altas_media <- c(columnas_altas_media, nombre_columna)
}
}
# Imprimir las columnas con medias mayores a 0.75
if (length(columnas_altas_media) > 0) {
cat("Las siguientes columnas tienen una media mayor a 0.75:\n")
print(columnas_altas_media)
} else {
cat("No hay columnas con una media mayor a 0.75.\n")
}
# Crear una versión limpia de datos_filtrados sin las columnas innecesarias
datos_limpios <- subset(datos_filtrados, select = 1:6)
# Mostrar las primeras filas de datos_limpios para verificar
head(datos_limpios)
# Eliminar filas con NA en las columnas relevantes
datos_limpios <- datos_limpios[complete.cases(datos_limpios[, c('calories', 'protein', 'fat', 'sodium')]), ]
# Crear un histograma para las calorías
ggplot(datos_limpios, aes(x = calories)) +
geom_histogram(binwidth = 50, fill = "skyblue", color = "black") +
labs(title = "Distribución de Calorías")
# Crear un histograma para la proteína
ggplot(datos_limpios, aes(x = protein)) +
geom_histogram(binwidth = 5, fill = "lightgreen", color = "black") +
labs(title = "Distribución de Proteína")
# Crear un histograma para la grasa
ggplot(datos_limpios, aes(x = fat)) +
geom_histogram(binwidth = 5, fill = "salmon", color = "black") +
labs(title = "Distribución de Grasa")
# Crear un histograma para el sodio
ggplot(datos_limpios, aes(x = sodium)) +
geom_histogram(binwidth = 50, fill = "orange", color = "black") +
labs(title = "Distribución de Sodio")
quantile(datos_limpios$calories, 0.95)
# Filtrar los datos para incluir solo aquellos dentro del cuantil 95
datos_limpios_cuantil_95 <- datos_limpios[apply(datos_limpios[, 3:ncol(datos_limpios)], 1, function(row) {
all(row <= 1407)
}), ]
datos_limpios_cuantil_95
View(datos_limpios_cuantil_95)
# Crear un histograma para las calorías
ggplot(datos_limpios_cuantil_95, aes(x = calories)) +
geom_histogram(binwidth = 50, fill = "skyblue", color = "black") +
labs(title = "Distribución de Calorías")
# Crear un histograma para la proteína
ggplot(datos_limpios, aes(x = protein)) +
geom_histogram(binwidth = 5, fill = "lightgreen", color = "black") +
labs(title = "Distribución de Proteína")
# Crear un histograma para las calorías
ggplot(datos_limpios_cuantil_95, aes(x = calories)) +
geom_histogram(binwidth = 50, fill = "skyblue", color = "black") +
labs(title = "Distribución de Calorías")
# Crear un histograma para la proteína
ggplot(datos_limpios_cuantil_95, aes(x = protein)) +
geom_histogram(binwidth = 5, fill = "lightgreen", color = "black") +
labs(title = "Distribución de Proteína")
# Crear un histograma para la grasa
ggplot(datos_limpios_cuantil_95, aes(x = fat)) +
geom_histogram(binwidth = 5, fill = "salmon", color = "black") +
labs(title = "Distribución de Grasa")
# Crear un histograma para las calorías
ggplot(datos_limpios_cuantil_95, aes(x = calories)) +
geom_histogram(binwidth = 50, fill = "skyblue", color = "black") +
labs(title = "Distribución de Calorías")
# Crear un histograma para la proteína
ggplot(datos_limpios_cuantil_95, aes(x = protein)) +
geom_histogram(binwidth = 5, fill = "lightgreen", color = "black") +
labs(title = "Distribución de Proteína")
# Crear un histograma para la grasa
ggplot(datos_limpios_cuantil_95, aes(x = fat)) +
geom_histogram(binwidth = 5, fill = "salmon", color = "black") +
labs(title = "Distribución de Grasa")
# Crear un histograma para las calorías
ggplot(datos_limpios_cuantil_95, aes(x = calories)) +
geom_histogram(binwidth = 50, fill = "skyblue", color = "black") +
labs(title = "Distribución de Calorías")
mean(datos_limpios_cuantil_95)
mean(datos_limpios_cuantil_95)
mean(datos_limpios_cuantil_95$calories)
source("~/Dev/AEDenso/Comida/src/main.R", echo=TRUE)
source("~/Dev/AEDenso/Comida/src/main.R", echo=TRUE)
source("~/Dev/AEDenso/Comida/src/main.R", echo=TRUE)
source("~/Dev/AEDenso/Comida/src/main.R", echo=TRUE)
# Mostrar un resumen descriptivo de las variables
summary(datos_limpios)
# Mostrar un resumen descriptivo de las variables
summary(datos_limpios_cuantil_95)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ calories , data = datos_limpios)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ protein, data = datos_limpios)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ fat, data = datos_limpios)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ sodium , data = datos_limpios)
# Resumen del modelo
summary(modelo)
summary(modelo)$coefficients
source("~/Dev/AEDenso/Comida/src/main.R", echo=TRUE)
source("~/Dev/AEDenso/Comida/src/main.R", echo=TRUE)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ calories + protein + fat + sodium, data = datos_limpios)
R
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ calories + protein + fat + sodium, data = datos_limpios)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ calories + protein + fat + sodium, data = datos_limpios)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ calories + protein + fat + sodium, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ calories, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ protein + fat + sodium, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal
modelo <- lm(rating ~ protein, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal Todas las variables
modelo <- lm(rating ~ calories + protein + fat + sodium, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Crear una versión limpia de datos_filtrados sin las columnas innecesarias
datos_limpios <- subset(datos_comida, select = 1:6)
# Mostrar las primeras filas de datos_limpios para verificar
head(datos_limpios)
# Eliminar filas con NA en las columnas relevantes
datos_limpios <- datos_limpios[complete.cases(datos_limpios[, c('calories', 'protein', 'fat', 'sodium')]), ]
# Crear un histograma para las calorías
ggplot(datos_limpios, aes(x = calories)) +
geom_histogram(binwidth = 50, fill = "skyblue", color = "black") +
labs(title = "Distribución de Calorías")
# Filtrar los datos para incluir solo aquellos dentro del cuantil 95
datos_limpios_cuantil_95 <- datos_limpios[apply(datos_limpios[, 3:ncol(datos_limpios)], 1, function(row) {
all(row <= 1407)
}), ]
# Mostrar un resumen descriptivo de las variables
summary(datos_limpios_cuantil_95)
# Crear un histograma para las calorías
ggplot(datos_limpios_cuantil_95, aes(x = calories)) +
geom_histogram(binwidth = 50, fill = "skyblue", color = "black") +
labs(title = "Distribución de Calorías")
# Crear un histograma para la proteína
ggplot(datos_limpios_cuantil_95, aes(x = protein)) +
geom_histogram(binwidth = 5, fill = "lightgreen", color = "black") +
labs(title = "Distribución de Proteína")
# Crear un histograma para la grasa
ggplot(datos_limpios_cuantil_95, aes(x = fat)) +
geom_histogram(binwidth = 5, fill = "salmon", color = "black") +
labs(title = "Distribución de Grasa")
# Ajustar el modelo de regresión lineal Todas las variables
modelo <- lm(rating ~ calories + protein + fat + sodium, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal Todas las variables
modelo <- lm(rating ~ calories + fat + sodium, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal Todas las variables
modelo <- lm(rating ~ fat + sodium, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal Todas las variables
modelo <- lm(rating ~ sodium, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Ajustar el modelo de regresión lineal Todas las variables
modelo <- lm(rating ~ fat, data = datos_limpios_cuantil_95)
# Resumen del modelo
summary(modelo)
# Prueba de normalidad de los residuos
shapiro.test(residuals(modelo))
library(lmtest)
install.packages("lmtest")
library(lmtest)
# Prueba de homocedasticidad
bptest(modelo)
# Gráficos de diagnóstico del modelo
par(mfrow = c(2, 2))
plot(modelo)
plot(modelo)$resifuals
# Crear un histograma para la grasa
ggplot(datos_limpios_cuantil_95, aes(x = fat, y = mean(rating))) +
geom_histogram(binwidth = 5, fill = "salmon", color = "black") +
labs(title = "Distribución de Grasa")
# Crear un histograma para la grasa
ggplot(datos_limpios_cuantil_95, aes(x = fat, y = mean(rating))) +
geom_histogram(binwidth = 5, fill = "salmon", color = "black") +
labs(title = "Distribución de Grasa")
# Crear un histograma para la grasa
ggplot(datos_limpios_cuantil_95, aes(x = fat)) +
geom_histogram(binwidth = 5, fill = "salmon", color = "black") +
labs(title = "Distribución de Grasa")
# Gráfico de dispersión para sodium vs rating
ggplot(datos_limpios, aes(x = sodium, y = rating)) +
geom_point(color = "blue") +
labs(title = "Sodium vs Rating",
x = "Sodium",
y = "Rating") +
theme_minimal()
# Gráfico de dispersión para sodium vs rating
ggplot(datos_limpios_cuantil_95, aes(x = sodium, y = rating)) +
geom_point(color = "blue") +
labs(title = "Sodium vs Rating",
x = "Sodium",
y = "Rating") +
theme_minimal()
# Gráfico de dispersión para fat vs rating
ggplot(datos_limpios_cuantil_95, aes(x = fat, y = rating)) +
geom_point(color = "red") +
labs(title = "Fat vs Rating",
x = "Fat",
y = "Rating") +
theme_minimal()
# Gráfico de boxplot para sodium vs rating
ggplot(datos_limpios, aes(x = as.factor(rating), y = sodium)) +
geom_boxplot(fill = "blue", alpha = 0.5) +
labs(title = "Sodium vs Rating",
x = "Rating",
y = "Sodium") +
theme_minimal()
# Gráfico de boxplot para sodium vs rating
ggplot(datos_limpios_cuantil_95, aes(x = as.factor(rating), y = sodium)) +
geom_boxplot(fill = "blue", alpha = 0.5) +
labs(title = "Sodium vs Rating",
x = "Rating",
y = "Sodium") +
theme_minimal()
ggplot(datos_limpios_cuantil_95, aes(x = as.factor(rating), y = fat)) +
geom_boxplot(fill = "blue", alpha = 0.5) +
labs(title = "Sodium vs Rating",
x = "Rating",
y = "Sodium") +
theme_minimal()
# Gráfico de densidad para sodium
ggplot(datos_limpios, aes(x = sodium)) +
geom_density(fill = "blue", alpha = 0.5) +
labs(title = "Distribución de Sodium",
x = "Sodium") +
theme_minimal()
# Gráfico de densidad para sodium
ggplot(datos_limpios_cuantil_95, aes(x = sodium)) +
geom_density(fill = "blue", alpha = 0.5) +
labs(title = "Distribución de Sodium",
x = "Sodium") +
theme_minimal()
# Gráfico de densidad para fat
ggplot(datos_limpios, aes(x = fat)) +
geom_density(fill = "blue", alpha = 0.5) +
labs(title = "Distribución de Sodium",
x = "Sodium") +
theme_minimal()
# Gráfico de densidad para fat
ggplot(datos_limpios_cuantil_95, aes(x = fat)) +
geom_density(fill = "blue", alpha = 0.5) +
labs(title = "Distribución de Sodium",
x = "Sodium") +
theme_minimal()
plot(modelo)
x = "Rating",
y = "Sodium") +
theme_minimal()
# Gráfico de boxplot para sodium vs rating
ggplot(datos_limpios_cuantil_95, aes(x = as.factor(rating), y = sodium)) +
geom_boxplot(fill = "blue", alpha = 0.5) +
labs(title = "Sodium vs Rating",
x = "Rating",
y = "Sodium") +
theme_minimal()
ggplot(datos_limpios_cuantil_95, aes(x = as.factor(rating), y = fat)) +
geom_boxplot(fill = "blue", alpha = 0.5) +
labs(title = "Sodium vs Rating",
x = "Rating",
y = "Sodium") +
theme_minimal()
ggplot(datos_limpios_cuantil_95, aes(x = as.factor(rating), y = fat)) +
geom_boxplot(fill = "blue", alpha = 0.5) +
labs(title = "Sodium vs Rating",
x = "Rating",
y = "Sodium") +
theme_minimal()
ggplot(datos_limpios_cuantil_95, aes(x = as.factor(rating), y = fat)) +
geom_boxplot(fill = "blue", alpha = 0.5) +
labs(title = "Fat vs Rating",
x = "Rating",
y = "Fat") +
theme_minimal()
# Gráficos de diagnóstico del modelo
par(mfrow = c(2, 2))
plot(modelo)
plot(modelo)
